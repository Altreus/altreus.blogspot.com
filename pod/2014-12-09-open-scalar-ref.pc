Did you know you can open a variable as a file handle?

This is a great trick that avoids temporary files. You can write to the
filehandle, and the stuff written thereto are available in the other variable.
I'm going to call the other variable the "buffer"; this is a common term for
a-place-where-data-get-stuffed.

Here's an example whereby I created an XLS spreadsheet entirely in memory and
uploaded it using L<https://metacpan.org/pod/WWW::Mechanize|WWW::Mechanize>. The
template for the spreadsheet came from C<__DATA__>, the
L<http://perldoc.perl.org/perldata.html#Special-Literals|special filehandle>
that reads stuff from the end of the script. 

This allowed me to embed a simple CSV in my script, amend it slightly, and then
upload it as an XLS, meaning I never had to have a binary XLS file committed to
git, nor even written temporarily to disk.

In the example below, a vehicle, identified by its VRM (registration plate) is
uploaded in an XLS spreadsheet with information about its sale. The C<$mech> in
the example is ready on the form where this file is uploaded.

The main problem this solves is that the VRM to put into the spreadsheet is
generated by the script itself, meaning that we can't just have an XLS file
waiting around to be uploaded. As noted, it is also preferable not to have to
edit an XLS file for any reason, essentially because this can't be done on the
command line - LibreOffice is required, or some Perl hijinks.

  open my $spreadsheet_fh, ">", \my $spreadsheet_buf;       # [1]
  my ($header, $line) = map { chomp; [split /,/] } <DATA>;  # [2]
  my $xls = Spreadsheet::WriteExcel->new($spreadsheet_fh);  # [3]
  my $sheet = $xls->add_worksheet();

  # processing

  $line->[0] = $vrm;

  $sheet->write_col('A1', [ $header, $line ]);              # [4]
  $xls->close;

  $mech->submit_form(
    with_fields => {
        file => [ [ undef, 'whatever', 
            Content => $spreadsheet_buf ],                  # [5]
        1 ]
    },
    button => 'submit',
  );

  # [5]
  __DATA__
  VRM,Price,Fees,Collection,Valeting,Prep costs
  ,2333,10,0,10,0

The key to this example is in [1], which looks like a normal
L<http://perldoc.perl.org/functions/open.html| C<open>> call except for the last
expression:

  \my $spreadsheet_buf;

This is a valid shortcut to declaring the C<$spreadsheet_buf> and then taking a
reference to that:

  my $spreadsheet_buf;
  open my $spreadsheet_fh, ">", \$spreadsheet_buf;

The clever part is that now, C<$spreadsheet_fh> is a normal filehandle that can
be used just like any other; just as if we'd used a filename instead of a scalar
reference. At [3] you can see a normal
L<https://metacpan.org/pod/Spreadsheet::WriteExcel|Spreadsheet::WriteExcel>
constructor, taking a filehandle as the argument, as
L<https://metacpan.org/pod/Spreadsheet::WriteExcel#new|documented>.

At [2] you can see C<DATA> in use, which reads from C<__DATA__> at [5]. This
also acts like a normal filehandle; C[<DATA>] reads linewise, and we have to
C<chomp> to remove the newlines.

We C<map> over these lines, chomping them and using C<split /,/> to turn them
into lists of strings; and this list is inside the arrayref constructor C<[...]>,
meaning we get an arrayref for each line.

At [4] we have processed sufficiently to have installed the VRM in the gap at
the front of the second line, i.e. the zeroth element of C<$line>, so
C<write_col> is employed to write both arrayrefs as rows (yes I know) into the
spreadsheet.

When we call C[$xls->close], this writes the spreadsheet to the filehandle. But
no file is created; instead, the data go to C<$spreadsheet_buf>. If we were to
print C<$spreadsheet_buf> to a file now, we would get an XLS we can open.

Instead, at [5], we use the trick
L<https://metacpan.org/pod/WWW::Mechanize#mech-submit_form|documented in
C<submit_form>> (ether++ for reading everyone's mind) to use the file data we
already have as the value of the form field.

This trick is remarkably useful. You can reopen C<STDOUT> to write
to your buffer:

  {
      local *STDOUT;

      open STDOUT, ">", \my $buffer;

      do_stuff_that_prints();

      do_stuff_with($buffer);
  }

but that's better written

  my ($buffer) = capture { do_stuff_that_prints() };

from L<https://metacpan.org/pod/Capture::Tiny|Capture::Tiny>.

=h2 See also

If you use L<https://metacpan.org/pod/IO::Handle|IO::Handle> then your
C<$spreadsheet_fh> will be an object like any other - but these days, you get
that simply by using lexical filehandles anyway.

L<https://metacpan.org/pod/IO::Scalar|IO::Scalar> seems like a decent OO-type
module to deal with this but also look nice.

L<https://metacpan.org/pod/IO::String|IO::String> also works with
strings-as-IO.

I've not tried either of these latter two, but YMMV etc.
